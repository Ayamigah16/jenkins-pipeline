# Jenkins LTS CI/CD Pipeline (DevSecOps + IaC)

## Overview
This project implements a secure CI/CD pipeline for a containerized Flask app, with:
- Terraform for AWS infrastructure provisioning
- Ansible for server configuration
- Jenkins declarative pipeline for build, test, scan, push, deploy, verify, and cleanup
- S3 + DynamoDB backend for Terraform remote state and locking

## Repository Layout
- `app` Flask application
- `tests` unit tests
- `Jenkinsfile` Jenkins declarative pipeline
- `infra/terraform/bootstrap` Terraform state backend bootstrap (S3 + DynamoDB)
- `infra/terraform/aws` Terraform AWS stack (VPC, EC2, IAM, ECR)
- `infra/ansible` Ansible playbooks and roles for Jenkins and deploy host
- `runbook.md` operational runbook
- `screenshots` evidence placeholders

## Deployment Architecture
- Jenkins EC2 (Amazon Linux 2) runs CI/CD stages and pushes image to ECR.
- ECR stores scanned image tags and performs scan-on-push.
- Deploy EC2 (Amazon Linux 2) runs the application container on port `80`.
- Jenkins deploys over SSH with health-checked staging (`3001`) and rollback.

## Setup Steps
1. Provision Terraform backend:
```bash
cd infra/terraform/bootstrap
terraform init
terraform apply -var='state_bucket_name=<globally-unique-bucket>' -var='aws_region=us-east-1'
```

2. Provision AWS infrastructure:
```bash
cd ../aws
cp terraform.tfvars.example terraform.tfvars
cp backend.hcl.example backend.hcl
terraform init -backend-config=backend.hcl
terraform apply
```

3. Configure hosts with Ansible:
```bash
cd ../../ansible
# optional: cp group_vars/all/vault.yml.example group_vars/all/vault.yml && ansible-vault encrypt group_vars/all/vault.yml
# optional fallback (instead of vault): export JENKINS_ADMIN_PASSWORD='<strong-password>'
./run-playbook.sh
```
`run-playbook.sh` loads `infra/ansible/.env` generated by Terraform.

4. Configure Jenkins job and credentials:
- `git_credentials` for GitHub checkout
- `ec2_ssh` SSH private key from `infra/keys/<key_pair_name>.pem`
- `registry_creds` only needed if `USE_ECR=false`

5. Set Jenkinsfile runtime values:
- `REGISTRY` to your ECR registry host (for example `123456789012.dkr.ecr.us-east-1.amazonaws.com`)
- `EC2_HOST` to deploy host public DNS from Terraform output
- keep `USE_ECR=true` for IAM-based ECR auth

## Security Controls
- Vulnerability and dependency scanning: `pip-audit`, `trivy fs`, `trivy image`
- Static analysis: `bandit`
- Container hardening: non-root user, read-only FS, dropped Linux capabilities
- Remote state security: S3 encryption + public access block + DynamoDB locking
- IAM: separate instance roles for Jenkins (ECR push) and deploy host (ECR pull)

## Rollback Process
- Deployment uses staging container on `3001` before cutover.
- If staging health check fails, production remains unchanged.
- If production post-switch check fails, pipeline restarts previous image automatically.

## Verification Checklist
- Terraform apply succeeds for backend and AWS stack
- Ansible playbook succeeds for both hosts
- Jenkins pipeline stages complete successfully
- ECR contains build tag and `latest`
- App responds at `http://<deploy_public_dns>/health`
